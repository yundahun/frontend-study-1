<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
</head>
<body>
  <script>
    // 내장 객체(JS 기본 제공)
    // 자바스크립트 엔진에 내장되어 필요한 경우 생성하여 사용
    // Object 객체는 모든 JS 객체의 최상위(루트) 객체
    // 그 외에도 String, Number, Date, Array, Math 등 다양한 객체가 존재

    // 1. String 객체
    // 문자열을 다루기 위한 객체로 문자열을 다룰 때 유용한 속성과 함수를 제공
    // 문자열 생성 2가지 방식
    // 변수 = new String('문자');
    // 변수 = '문자'; => 리터럴 방식
    document.write('<h1>String 객체</h1>');

    // 1) length
    // 문자열 길이를 반환하는 속성
    document.write('<h4>문자열 길이</h4>');
    const txt = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ';
    const sln = txt.length;
    document.write(sln, '<br>');

    // 2) indexOf()
    // 문자열 안에 특정 문자열이 존재하는지 찾고,
    // 있다면 찾고자 하는 문자열이 시작되는 index를 반환(처음 나타나는 위치)
    // 발견하지 못하면 -1을 반환
    document.write('<h4>문자열 검색</h4>');
    let str = 'Please locate where "locate" occurs!';
    let pos = str.indexOf('locate');
    document.write(pos, '<br>');

    // 3) lastIndexOf()
    // 문자열 안에 특정 문자열이 존재하는지를 찾는 것은 동일
    // 찾고자 하는 문자열이 둘 이상 발견되면 제일 마지막에 발견된 문자열의 index를 반환(문자열 끝에서부터 검색)
    // 발견하지 못하면 -1을 반환
    pos = str.lastIndexOf('locate');
    document.write(pos, '<br>');

    // 검색 시작 위치(index) 지정 가능
    pos = str.indexOf('locate', 15); // 15번째 index부터 찾기 시작
    document.write(pos, '<br>');
    pos = str.lastIndexOf('locate', 15);
    document.write(pos, '<br>');

    // (ES6차) includes()
    // 지정된 문자열이 포함된 경우 true를 반환
    // 그렇지 않으면 false를 반환
    pos = str.includes('locate');
    document.write(pos, '<br>');
    pos = str.includes('locate', 15);
    document.write(pos, '<br>');

    // 실습: 사용자로부터 입력받은 이메일 주소 유효성 검사
    // 정규표현식을 안쓰는 경우(실무에서는 정규식 사용!!)
    document.write('<h4>실습: 이메일 주소 유효성 검사</h4>');
    // const userEmail = prompt('당신의 이메일 주소는?');
    // const arrUrl = ['.co.kr', '.com', '.net', '.or.kr', '.go.kr'];

    // let check1 = false;
    // let check2 = false;

    // if (userEmail.indexOf('@') > 0) { // @가 있는지 검사
    //   check1 = true;
    // }

    // for (let i = 0; i < arrUrl.length; i++) {
    //   if (userEmail.indexOf(arrUrl[i]) > 0) { // 도메인 검사
    //     check2 = true;
    //     break;
    //   }
    // }

    // if (check1 && check2) {
    //   document.write(userEmail, '<br>');
    // } else {
    //   alert('이메일 형식이 잘못되었습니다.');
    // }

    // (참고) 정규 표현식(정규식)
    // 문자열에서 특정 문자 조합을 찾기 위한 패턴
    // 주로 회원가입 시 유효성 검사(패스워드, 이메일, 전화번호 포맷 검증 등)에 사용

    // 4) slice()
    // 시작 위치와 종료 위치를 주면, 문자열에서 해당 부분을 잘라내서 반환
    document.write('<h4>문자열 추출</h4>');
    str = 'Apple, Banana, Kiwi';
    let res = str.slice(7, 13);
    document.write(res, '<br>');

    // 두번째 인수인 종료 위치를 생략하면, 시작 위치에서 문자열의 마지막 위치까지 잘라내서 반환
    res = str.slice(7);
    document.write(res, '<br>');

    // 첫번째 인수인 시작 위치를 음수로 주면, 문자열의 끝에서부터 거꾸로 읽게 됨
    res = str.slice(-12);
    document.write(res, '<br>');

    // 5) substring()
    // slice() 함수와 동일한 기능
    // 인수로 음수를 허용하지 않는다는 차이
    res = str.substring(7, 13);
    document.write(res, '<br>');
    res = str.substring(7);
    document.write(res, '<br>');

    // 6) substr()
    // 시작 위치에서 지정한 길이 만큼 잘라내서 반환
    res = str.substr(7, 6);
    document.write(res, '<br>');
    res = str.substr(7);
    document.write(res, '<br>');
    res = str.substr(-12);
    document.write(res, '<br>');

    // 7) replace()
    // 문자열 내의 특정 문자열을 지정한 문자열로 바꾸고 새 문자열을 반환
    // 이때 바꾸려는 문자열이 하나 이상 있더라도 처음 발견된 문자열만 바꾸게 됨
    document.write('<h4>문자열 변환</h4>');
    str = 'Please visit Seoul and Seoul!';
    let n = str.replace('Seoul', 'Jeju');
    document.write(n, '<br>');

    // 대소문자 구분
    n = str.replace('SEOUL', 'Jeju');
    document.write(n, '<br>');

    // 정규 표현식과 함께 사용
    n = str.replace(/SEOUL/i, 'Jeju'); // i=insensitive, 대소문자를 구분하지 않겠다는 뜻
    document.write(n, '<br>');
    n = str.replace(/Seoul/g, 'Jeju'); // g=global, 일치하는 모든 문자열을 찾겠다는 뜻
    document.write(n, '<br>');
    
    // 8) toUpperCase(), toLowerCase()
    // 문자열을 모두 대문자로 변경
    let text1 = 'Hello World!';
    let text2 = text1.toUpperCase();
    document.write(text2, '<br>');

    // 문자열을 모두 소문자로 변경
    text2 = text1.toLowerCase();
    document.write(text2, '<br>');

    // 실습: 주민등록번호를 입력받은 후 정보가 노출되지 않도록 뒤의 여섯자리는 ******로 출력하세요.
    document.write('<h4>실습: 주민등록번호 마스킹</h4>');
    // const userSsn = prompt('주민등록번호를 입력하세요.');
    
    // // 123456-1234567 -> 123456-1******
    // const maskSsn = userSsn.substring(0, userSsn.length - 6) + '******';
    // document.write(maskSsn, '<br>');
    // document.write(userSsn.substr(0, 8) + '******', '<br>');

    // 9) concat()
    // 2개 이상의 문자열을 하나의 문자열로 합치고 새 문자열로 반환
    document.write('<h4>문자열 결합</h4>');
    text1 = 'Hello';
    text2 = 'World!';
    let text3 = text1.concat(' ', text2);
    document.write(text3, '<br>');
    let text4 = text1 + ' ' + text2;
    document.write(text4, '<br>');

    // 10) trim
    // 문자열의 앞, 뒤 공백을 모두 제거
    str = '       Hello World!        ';
    console.log(str);
    console.log(str.trim());

    // 11) charAt()
    // 문자열에서 특정 인덱스에 해당하는 문자 하나를 반환
    document.write('<h4>특정 문자 1개 추출</h4>');
    str = 'HELLO WORLD';
    document.write(str.charAt(0), '<br>');

    // 12) charCodeAt()
    // 문자열에서 특정 인덱스에 해당하는 문자 하나의 유니코드 값을 반환
    document.write(str.charCodeAt(0), '<br>');
    document.write('가각갸나다'.charCodeAt(1), '<br>');

    // 13) split()
    // 특정 구분자를 기준으로 문자열을 분리해서 배열로 반환
    document.write('<h4>문자열 배열로 쪼개기</h4>');
    const birthday = '2022-10-15';
    const arrBirthday = birthday.split('-'); // 하이픈(-)을 기준으로 문자열을 분리
    console.log(arrBirthday);


    // 2. Array 객체
    // 여러 데이터를 순차적으로 저장 가능한 객체로 배열을 다룰 때 유용한 속성과 함수를 제공
    // 배열 객체 생성 3가지 방식
    // 첫번째 방식
    // 변수 = new Array(값1, 값2, 값3);

    // 두번째 방식
    // 변수 = new Array();
    // 변수[0] = 값1;
    // 변수[1] = 값2;
    // 변수[2] = 값3;

    // 세번째 방식
    // 변수 = [값1, 값2, 값3]; => 리터럴 방식

    document.write('<h1>Array 객체</h1>');
    const arr = ['Apple', 'Banana', 'Mango'];

    // 배열 요소 변경
    // 인덱스로 접근해서 새로운 요소를 할당
    arr[0] = 'Kiwi';
    console.log(arr);

    // 배열 요소 접근
    document.write('<h4>배열값 가져오기-1</h4>');
    document.write(arr[0], '<br>');
    document.write(arr[1], '<br>');
    document.write(arr[2], '<br>');

    document.write('<h4>배열값 가져오기-2</h4>');
    for (let i = 0; i < arr.length; i++) {
      document.write(arr[i], '<br>');
    }
    
    document.write('<h4>배열값 가져오기-3(권장 안함)</h4>');
    for (const i in arr) { // Key 값을 가져옴
      document.write(arr[i], '<br>');
    }
    
    document.write('<h4>배열값 가져오기-4</h4>');
    for (const el of arr) { // Value 값을 가져옴
      document.write(el, '<br>');
    }
    
    document.write('<h4>배열값 가져오기-5</h4>');
    arr.forEach(function (element, index) {
      document.write(index, ': ', element, '<br>');
    });

    // 1) toString()
    // 배열 안의 모든 요소를 쉼표(,)를 이용해 결합해서 하나의 문자열로 반환
    let fruits = ['Banana', 'Orange', 'Apple', 'Mango'];
    console.log(fruits.toString());

    // 2) join()
    // 배열 안의 모든 요소를 지정한 문자를 이용해 결합해서 하나의 문자열로 반환
    console.log(fruits.join(' * '));

    // 3) pop()
    // 배열에서 마지막 데이터를 제거하고, 마지막 데이터를 반환
    // 원본 배열이 변경됨
    let x = fruits.pop();
    console.log(x);
    console.log(fruits);
    
    // 4) shift()
    // 배열에서 첫 번째 데이터를 제거하고, 첫 번째 데이터를 반환
    // 원본 배열이 변경됨
    x = fruits.shift();
    console.log(x);
    console.log(fruits);

    // 5) push()
    // 배열에 새로운 요소를 추가하고, 배열의 길이를 반환
    // 원본 배열이 변경됨
    let ln = fruits.push('Mango');
    console.log(fruits);
    console.log(ln);

    // 6) unshift()
    // 배열의 맨 앞에 요소를 추가하고, 배열의 길이를 반환
    // 원본 배열이 변경됨
    ln = fruits.unshift('Banana');
    console.log(fruits);
    console.log(ln);

    // 7) splice()
    // 새로운 요소를 특정 위치에 추가하거나 기존 요소를 삭제할 수도 있음
    // 원본 배열이 변경됨
    // fruits.splice(index, howmany, item1, ..., itemX)
    // index: 항목을 추가하거나 제거할 인덱스 번호
    // howmany: 제거할 항목 수
    // 나머지 파라미터: 추가할 새 요소
    fruits.splice(2, 0, 'Lemon', 'Kiwi');
    console.log(fruits);

    // 8) concat()
    // 2개 이상의 배열을 하나의 배열로 결합
    // 새로운 배열로 반환
    const arr1 = ['Cecil', 'Lon'];
    const arr2 = ['Emil', 'Tobi', 'Lin'];
    const arr3 = ['Robin', 'Morgan'];
    const myChildren = arr1.concat(arr2, arr3);
    console.log(myChildren);

    // 9) slice()
    // 지정된 시작과 끝 위치(포함되지 않음) 구간만큼 잘라내서 반환
    // 새로운 배열로 반환
    fruits = ['Banana', 'Orange', 'Lemon', 'Apple', 'Mango'];
    const citrus = fruits.slice(3);
    console.log(citrus);
    const citrus2 = fruits.slice(1, 3);
    console.log(citrus2);

    // 10) sort()
    // 배열에 문자형 데이터가 있는 경우 오름차순으로 정렬
    // 원본 배열이 변경됨
    fruits = ['Banana', 'Orange', 'Apple', 'Mango'];
    fruits.sort();
    console.log(fruits);

    // 배열 안에 숫자형 데이터가 있더라도 기본적으로는 문자로 인식해서 오름차순으로 정렬
    const points = [40, 100, 1, 5, 25, 10];
    points.sort();
    console.log(points);
    // '25'는 '100'보다 크다. 왜냐하면 '2'가 '1'보다 크기 때문
    // 그래서 숫자 값으로 정렬하려면 정렬 (비교) 함수를 정의해서 사용해야 함
    // array.sort(정렬함수);
    // 정렬함수: function (a, b) { return a - b; }
    points.sort(function (a, b) { return a - b; });
    console.log(points);
    // 정렬 원리
    // 음수가 나오면 a, b 순으로 두 요소의 위치를 바꾸지 않음
    // 양수가 나오면 b, a 순으로 두 요소의 위치를 바꿈
    // 0이 나오면 변화 없음
    
    // Quiz: 숫자 데이터 내리차순 정렬하기
    points.sort(function (a, b) { return b - a; });
    console.log(points);

    // 활용 Tip:
    // Object의 특정 키를 기준으로 sort() 함수를 사용하는 경우가 많음
    // 예: 쇼핑몰 상품 목록에서 가격 높은 순, 낮은 순, 리뷰 많은 순, 누적 판매 순
    // 실습: 아래 사람들을 점수가 높은 순으로 정렬하기
    const persons = [
      {
        name: '유재석',
        point: 78,
        city: '서울',
      },
      {
        name: '김종국',
        point: 92,
        city: '서울',
      },
      {
        name: '양세찬',
        point: 76,
        city: '제주',
      },
      {
        name: '하하',
        point: 81,
        city: '서울',
      },
    ];
  </script>
</body>
</html>